use std::str::FromStr;
use std::path::PathBuf;
use crate::{Lines, ParsingArgs};
use bril_rs::{AbstractProgram, AbstractFunction, AbstractArgument, AbstractCode, AbstractInstruction, ConstOps, AbstractType, Literal};

/* todo: want to feature flag these as well

#[cfg(feature = "import")]
use bril_rs::{Import, ImportedFunction};

#[cfg(feature = "char")]
use crate::escape_control_chars;
*/

grammar(lines : &Lines);

match {
    "const", "true", "false", "from", "import", "as" // keywords get special priority
} else {
    r"[[:space:]]*" => { }, /// Whitespace
    r"#[^\n\r]*[\n\r]*" => { }, /// Comments
    r"(\+|-)?[0-9]+" => INT_TOKEN, // int
    r"(\+|-)?(((([0-9]+\.?[0-9]*)|(\.[0-9]+))(E|e)(\+|-)?[0-9]+)|(([0-9]+\.[0-9]*)|(\.[0-9]+)))" => FLOAT_TOKEN, // https://stackoverflow.com/questions/12643009/regular-expression-for-floating-point-numbers
    r"(_|%|[[:alpha:]])(_|%|\.|[[:alnum:]])*" => IDENT_TOKEN,
    // TODO: Want to feature flag this as well
    r"('.')|('\\[0abtnvfr]')" => CHAR_TOKEN,
    r#""[^"]*""# => STRING_TOKEN,
    _
}

pub AbstractProgram : AbstractProgram = {
    #[cfg(feature = "import")]
    <i: (<Imports>)*> <f :(<AbstractFunction>)*> => AbstractProgram {
        imports: i,
        functions : f,
    },
    #[cfg(not(feature = "import"))]
    <f :(<AbstractFunction>)*> => AbstractProgram {
        functions : f,
    }
}

#[cfg(feature = "import")]
Imports : bril_rs::Import = {
    "from" <p: Path> "import" <n:Comma<ImportedFunction>> ";" => {
        bril_rs::Import {
            path: p,
            functions: n,
        }
    }
}

#[cfg(feature = "import")]
ImportedFunction : bril_rs::ImportedFunction = {
    <n:Func> <a:Alias?> => {
        bril_rs::ImportedFunction {
            name: n,
            alias: a,
        }
    }
}

#[cfg(feature = "import")]
Alias : String = {
    "as" <a:Func> => {
        a
    }
}

AbstractFunction : AbstractFunction = {
    <loc:@L> <f: Func> <a: (Argument_List)?> <t:OutputType?> <loc2:@R> "{" <c :(<AbstractCode>)*> "}" => {let a = a.unwrap_or_default(); AbstractFunction {
        name : f,
        args : a,
        return_type : t,
        instrs: c,
        pos : lines.get_position(loc, loc2),
    }}
}

OutputType : AbstractType = {
    ":" <t:AbstractType> => t
}

Argument_List : Vec<AbstractArgument> = {
    "(" <a : Comma<AbstractArgument>> ")" => a,
}

AbstractArgument : AbstractArgument = {
   <i:Ident> ":" <t: AbstractType> => AbstractArgument {
        name : i,
        arg_type : t,
    }
}

AbstractCode : AbstractCode = {
    <loc:@L> <l: Label> ":" <loc2:@R> => AbstractCode::Label{ label : l, pos : lines.get_position(loc, loc2)},
    <i: AbstractInstruction> => AbstractCode::Instruction(i),
}

AbstractInstruction : AbstractInstruction = {
    <loc:@L> <i:Ident> <t:(":" <AbstractType>)?> "=" <c: ConstOps> <l: Literal> ";" <loc2:@R> => AbstractInstruction::Constant {
        op : c,
        dest : i,
        const_type : t,
        value : l,
        pos : lines.get_position(loc, loc2),
    },
    <loc:@L> <i:Ident> <t:(":" <AbstractType>)?> "=" <v:Ident> <f :(<Args>)*> ";" <loc2:@R> => {
        let mut a_vec = Vec::new();
        let mut f_vec = Vec::new();
        let mut l_vec = Vec::new();
        for x in f {
            match x {
                ParsingArgs::Ident(arg_name) => {a_vec.push(arg_name)}
                ParsingArgs::Func(arg_name) => {f_vec.push(arg_name)}
                ParsingArgs::Label(arg_name) => {l_vec.push(arg_name)}
            }
        }
        AbstractInstruction::Value {
            op: v,
            dest: i,
            op_type : t,
            args: a_vec,
            funcs: f_vec,
            labels: l_vec,
            pos : lines.get_position(loc, loc2),
        }
    },
    <loc:@L> <e:Ident> <f :(<Args>)*> ";" <loc2:@R> => {
        let mut a_vec = Vec::new();
        let mut f_vec = Vec::new();
        let mut l_vec = Vec::new();
        for x in f {
            match x {
                ParsingArgs::Ident(arg_name) => {a_vec.push(arg_name)}
                ParsingArgs::Func(arg_name) => {f_vec.push(arg_name)}
                ParsingArgs::Label(arg_name) => {l_vec.push(arg_name)}
            }
        }
        AbstractInstruction::Effect {
            op: e,
            args: a_vec,
            funcs: f_vec,
            labels: l_vec,
            pos : lines.get_position(loc, loc2),
        }
    }

}

ConstOps : ConstOps = {
    "const" => ConstOps::Const,
}

AbstractType : AbstractType = {
    <t:Ident> => AbstractType::Primitive(t),
    #[cfg(feature = "memory")]
    <p:Ident> "<" <t:AbstractType> ">" => AbstractType::Parameterized(p, Box::new(t)),
}

// We can't match on const because of a reduce-reduce conflict
Ident: String = {
    <s : IDENT_TOKEN> => s.to_string(),
    "true" => "true".to_owned(),
    "false" => "false".to_owned(),
}

Args: ParsingArgs = {
    <f:Func> => ParsingArgs::Func(f),
    <l:Label> => ParsingArgs::Label(l),
    <i:Ident> => ParsingArgs::Ident(i),
}

pub Func : String = {
    "@"<i:Ident> => i,
}

Path: PathBuf = {
    <p:STRING_TOKEN> => {
        PathBuf::from(p.trim_matches('\"'))
    }
}

Label: String = {
    "."<i:Ident> => i,
}

Literal: Literal = {
    <n: Num> => Literal::Int(n),
    <b: Bool> => Literal::Bool(b),
    #[cfg(feature = "float")]
    <f: Float> => Literal::Float(f),
    #[cfg(feature = "char")]
    <c: Char> => Literal::Char(c),
}

Num: i64 = <s:INT_TOKEN> => i64::from_str(s).unwrap();
Bool: bool = {
    "true" => true,
    "false" => false,
}

#[cfg(feature = "float")]
Float: f64 = <f:FLOAT_TOKEN> => f64::from_str(f).unwrap();

#[cfg(feature = "char")]
Char: char = <c:CHAR_TOKEN> => {let c = c.trim_matches('\''); crate::escape_control_chars(c).unwrap()};

// https://lalrpop.github.io/lalrpop/tutorial/006_macros.html
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}