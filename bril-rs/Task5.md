# Task 5

I found SSA implementation to be a difficult task due to all of the corner cases that can occur. I read [the ssa book](http://ssabook.gforge.inria.fr/latest/book-full.pdf) from Inria a couple of times to figure out the basis of this transformation. Finding a list of dominators was a straight forward dataflow analysis for which I could use my framework from the previous task. I then broke up the rest of the setup into functions to a dominator tree, a map to get the immediate dominator of a given block, and the dominance frontier. I then created a neat little function to find the iterative dominance frontier. Given the recursive and repetiveness of my solution, I had a bit of fun in playing with the Cached crate. This crate uses a macro to help memoize your functions. The performance implications of this were left untested but it was a cool crate to try out. At this point I had built enough tools to actually do the conversion to ssa form. This involved using the iterative dominance frontier to find where phi nodes needed to be inserted, inserting them, and then going back through to make all of the variable names unique. Undoing ssa is trivial in comparison, it's simply a matter of going through and for every phi node, adding the correct assignment instruction to the correct predecessor block. I then have a flag to go back through and try to unmangle all of the names from their ssa form.

The code for this is in [ssa.rs](src/ssa.rs).
